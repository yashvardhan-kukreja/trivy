// Code generated by mockery v1.0.0. DO NOT EDIT.

package vulnerability

import (
	context "context"

	pkgtypes "github.com/aquasecurity/trivy-db/pkg/types"
	mock "github.com/stretchr/testify/mock"

	types "github.com/aquasecurity/trivy/pkg/types"
)

// MockOperation is an autogenerated mock type for the Operation type
type MockOperation struct {
	mock.Mock
}

type OperationFillInfoArgs struct {
	Vulns              []types.DetectedVulnerability
	VulnsAnything      bool
	ReportType         string
	ReportTypeAnything bool
}

type OperationFillInfoExpectation struct {
	Args OperationFillInfoArgs
}

func (_m *MockOperation) ApplyFillInfoExpectation(e OperationFillInfoExpectation) {
	var args []interface{}
	if e.Args.VulnsAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulns)
	}
	if e.Args.ReportTypeAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.ReportType)
	}
	_m.On("FillInfo", args...)
}

func (_m *MockOperation) ApplyFillInfoExpectations(expectations []OperationFillInfoExpectation) {
	for _, e := range expectations {
		_m.ApplyFillInfoExpectation(e)
	}
}

// FillInfo provides a mock function with given fields: vulns, reportType
func (_m *MockOperation) FillInfo(vulns []types.DetectedVulnerability, reportType string) {
	_m.Called(vulns, reportType)
}

type OperationFilterArgs struct {
	Ctx                   context.Context
	CtxAnything           bool
	Vulns                 []types.DetectedVulnerability
	VulnsAnything         bool
	Severities            []pkgtypes.Severity
	SeveritiesAnything    bool
	IgnoreUnfixed         bool
	IgnoreUnfixedAnything bool
	IgnoreFile            string
	IgnoreFileAnything    bool
	Policy                string
	PolicyAnything        bool
}

type OperationFilterReturns struct {
	_a0 []types.DetectedVulnerability
	_a1 error
}

type OperationFilterExpectation struct {
	Args    OperationFilterArgs
	Returns OperationFilterReturns
}

func (_m *MockOperation) ApplyFilterExpectation(e OperationFilterExpectation) {
	var args []interface{}
	if e.Args.CtxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Ctx)
	}
	if e.Args.VulnsAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulns)
	}
	if e.Args.SeveritiesAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Severities)
	}
	if e.Args.IgnoreUnfixedAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.IgnoreUnfixed)
	}
	if e.Args.IgnoreFileAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.IgnoreFile)
	}
	if e.Args.PolicyAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Policy)
	}
	_m.On("Filter", args...).Return(e.Returns._a0, e.Returns._a1)
}

func (_m *MockOperation) ApplyFilterExpectations(expectations []OperationFilterExpectation) {
	for _, e := range expectations {
		_m.ApplyFilterExpectation(e)
	}
}

// Filter provides a mock function with given fields: ctx, vulns, severities, ignoreUnfixed, ignoreFile, policy
func (_m *MockOperation) Filter(ctx context.Context, vulns []types.DetectedVulnerability, severities []pkgtypes.Severity, ignoreUnfixed bool, ignoreFile string, policy string) ([]types.DetectedVulnerability, error) {
	ret := _m.Called(ctx, vulns, severities, ignoreUnfixed, ignoreFile, policy)

	var r0 []types.DetectedVulnerability
	if rf, ok := ret.Get(0).(func(context.Context, []types.DetectedVulnerability, []pkgtypes.Severity, bool, string, string) []types.DetectedVulnerability); ok {
		r0 = rf(ctx, vulns, severities, ignoreUnfixed, ignoreFile, policy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.DetectedVulnerability)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []types.DetectedVulnerability, []pkgtypes.Severity, bool, string, string) error); ok {
		r1 = rf(ctx, vulns, severities, ignoreUnfixed, ignoreFile, policy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
